<div id="page-main-content">
	<section id="main-content-section">
		<h1>User manual</h1>
		
		<p>This user manual describes how to set up and use bean-cp library. It covers all available features. Before you start you have to
		have good knowledge of Java programming language including lambda expressions. If you get any trouble please checkout
		<a href="#support">support</a> page.</p>
		
		<p><a href="https://github.com/erchu/bean-cp/tree/gh-pages/sample-source-code/src/com/github/erchu/beancp/tutorial">Examples source code
		is available on GitHub</a>. Apart of user manual you may also find helpful to read unit tests source code included in
		<a href="download/release/1.0/beancp-1.0-sources.jar">beancp-1.0-sources.jar</a>.</p>
		
		<h2 id="setting-up">Setting up environment</h2>
		
		<p>Firstly, bean-cp requires Java version 8 or later. If you don't have one please download it from
		<a href="http://www.oracle.com/technetwork/java/javase/overview/index.html">Oracle website</a>, install and then continue with this
		user manual.</p>
		
		<p>You have generally two options to get a copy of bean-cp:</p>
		
		<ol>
			<li><strong>Download it from this website.</strong> Note that bean-cp has two dependencies: Apache Commons Lang and Javassist.
			File <a href="download/release/1.0/beancp-1.0-all.zip">beancp-1.0-all.zip</a> contains library and all dependencies. Otherwise
			you can download from this site only <a href="download/release/1.0/beancp-1.0.jar">beancp-1.0.jar</a> library file and get
			dependencies from another source.</li>
			<li><strong>Use build system like Maven.</strong> The artifacts can be found in Maven's central repository.
			Dependency declaration:
<pre class="brush: xml; gutter: false;">
&lt;dependency&gt;
	&lt;groupId&gt;com.github.erchu&lt;/groupId&gt;
	&lt;artifactId&gt;beancp&lt;/artifactId&gt;
	&lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
			</li>
		</ol>
		
		<p>If you want to use different version of Apache Commons Lang or Javassist recommended way is to download
		<a href="download/release/1.0/beancp-1.0-sources.jar">bean-cp source code</a> and execute all bean-cp unit tests against versions you would
		like to use to prove compatibility.</p>
		
		<h2 id="first-mapping">First mapping</h2>
		
		<p>There are few mapping scenarios supported. We will start with declarative map used to map from one
		<a href="http://en.wikipedia.org/wiki/JavaBeans">JavaBean</a> to another JavaBean.</p>

		<p>Let's start with simple example. Suppose we have following two classes in our domain model:</p>
		
<pre class="brush: java; gutter: false;">
public class Customer {
		
	private long id;
	
	private String fullName;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getFullName() {
		return fullName;
	}

	public void setFullName(String fullName) {
		this.fullName = fullName;
	}
}

public class Order {
	
	private long id;
	
	private Customer customer;
	
	private BigDecimal totalAmount;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public Customer getCustomer() {
		return customer;
	}

	public void setCustomer(Customer customer) {
		this.customer = customer;
	}

	public BigDecimal getTotalAmount() {
		return totalAmount;
	}

	public void setTotalAmount(BigDecimal totalAmount) {
		this.totalAmount = totalAmount;
	}
}</pre>

		<p>Our task is to map those classes to data transfer object:</p>
		
<pre class="brush: java; gutter: false;">
public static class OrderOverviewDto {
	
	private long id;
	
	private String customerFullName;
	
	private BigDecimal totalAmount;

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public String getCustomerFullName() {
		return customerFullName;
	}

	public void setCustomerFullName(String customerFullName) {
		this.customerFullName = customerFullName;
	}

	public BigDecimal getTotalAmount() {
		return totalAmount;
	}

	public void setTotalAmount(BigDecimal totalAmount) {
		this.totalAmount = totalAmount;
	}
}</pre>

	<p>Hare is how to do that in bean-cp way:

<pre class="brush: java">
Mapper mapper
	= new MapperBuilder()
	.addMap(
		Order.class,
		OrderOverviewDto.class,
		(conf, source, destination) -> conf
			.bind(source::getId, destination::setId)
			.bind(source.getCustomer()::getFullName, destination::setCustomerFullName)
			.bind(source::getTotalAmount, destination::setTotalAmount))
	.buildMapper();
</pre>
		
		<p>When you use bean-cp you configure mappings and build mapper from configuration to preform mappings. To configure mappings you need
		to create instance of <a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html"><code>MapperBuilder</code></a> (line 2),
		add one or mappings (line 3 - 9). To perform mappings you need to call
		<a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html#buildMapper--"><code>buildMapper()</code></a> method to get
		<a href="apidocs/release/1.0/com/github/erchu/beancp/Mapper.html"><code>Mapper</code></a> instance (line 10) and then use it to map objects.
		Source and destination classes must have default (with no arguments) public or protected constructor. </p>
		
		<p>There are three options to add mapping configuration: declarative map, converter and convention. In this section we will focus on
		declarative maps. They are used to map from one JavaBean to another. To add declarative map call
		<a href="apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html#addMap-java.lang.Class-java.lang.Class-com.github.erchu.beancp.DeclarativeMapSetup-"><code>addMap()</code></a>
		method (line 3). This method takes three parameters: source class (in our example: <code>Order</code>), destination class (in our example:
		<code>OrderOverviewDto</code>) and map declaration. Map declaration is lambda expression taking three parameters: configuration reference,
		source object reference and destination object reference (line 6). Finally we define map using series of operations like binding from source
		member to destination member using
		<a href="apidocs/release/1.0/com/github/erchu/beancp/DeclarativeMap.html#bind-java.util.function.Supplier-java.util.function.Consumer-com.github.erchu.beancp.BindingOption...-"><code>bind()</code></a>
		(line 7, 8 and 9).</p>
		
		<p>Let see how to perform mapping using <a href="apidocs/release/1.0/com/github/erchu/beancp/Mapper.html"><code>Mapper</code></a>. There are
		two options here. If you already have destination object instance and only want to fill it with data from source object then you write code
		like this:</p>
		
<pre class="brush: java">
	Order order = new Order();
	OrderOverviewDto destination = new OrderOverviewDto();
	
	// Some other stuff here
	
	mapper.map(order, destination);
</pre>

		<p>Otherwise bean-cp can create destination object instance for you:</p>
		
<pre class="brush: java">
	Order order = new Order();
	
	// Some other stuff here
	
	OrderOverviewDto destination = mapper.map(order, OrderOverviewDto.class);
</pre>

		<p>That's it! First mapping is ready.</p>

		<h2 id="declarative-maps">Declarative maps in deep</h2>
		
		<h3 id="bind-constant">Bind constant</h3>

		<p>Firstly, there are more binding options. Destination member can be bind to constant using <code>bindConstant</code>. For example
		<code>bindConstant("", destination::setCustomerFullName)</code> will bind empty string to <code>customerFullName</code> property.</p>
		
		<h3 id="calculated-members">Calculated members</h3>
		
		<p>Method <code>bind</code> supports also calculated members. For example:</p>

<pre class="brush: java; gutter: false;">
	bind(
		() -> source.getTotalAmount().setScale(2, RoundingMode.CEILING),
		destination::setTotalAmount)
</pre>

		<p>calculates rounded value of <code>totalAmount</code> value. Note that name of <code>setScale</code> method of <code>BigDecimal</code>
		class can be misleading, because it do not modifies current instance but returns new one (see
		<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#setScale(int,%20java.math.RoundingMode)">Java Platform API specification</a>).
		Term "calculated member" is not limited to mathematical calculations &#8211; any expression which returns value of proper type can be used. Those
		calculation should have no side effects, especially should not modify source object.</p>
		
		<h3 id="conditional-mapping">Conditional mapping</h3>
		
		<p>Moreover <code>bind</code> and <code>bindConstant</code> methods supports <code>BindingOptions</code>. This allows to perform conditional
		mappings and null substitution. Mapping condition defines when to execute mapping. For example following binding code will map only positive
		values of <code>totalAmount</code> property:</p>
		
<pre class="brush: java; gutter: false;">
	bind(
		source::getTotalAmount,
		destination::setTotalAmount,
		BindingOption.mapWhen(() -> source.getTotalAmount().compareTo(BigDecimal.ZERO) > 0)
</pre>

		<h3 id="null-substitution">Null substitution</h3>

		<p>Binding options can be also used to substitute <code>null</code> value with specified value. For example following binding declaration will substitute
		<code>null</code> value with <code>"unknown"</code> string.</p>

<pre class="brush: java; gutter: false;">
	bind(
		source.getCustomer()::getFullName,
		destination::setCustomerFullName,
		BindingOption.withNullSubstitution("unknown"))
</pre>

		<h3 id="map-inner-objects">Map inner objects</h3>

		<p>Suppose we have in your application classes presented on below diagram:</p>
		
		<img src="images/user-manual/diagram1.png" width="679" height="171" />
		
		<p>Now suppose you want to map <code>Line</code> to this model:</p>
		
		<img src="images/user-manual/diagram2.png" width="479" height="162" />
		
		<p>What is new about this situation (comparing to previous examples) is need for map inner object. <code>LineDto</code> do not references
		<code>Point</code>, but references <code>PointDto</code>. This means that we need to map in first step <code>Point</code> to <code>PointDto</code>
		and then map <code>Line</code> to <code>LineDto</code>. Our map configuration should look like this:</p>

<pre class="brush: java;">
	Mapper mapper = new MapperBuilder()
		.addMap(Point.class, PointDto.class, (conf, source, destination) -> conf
			.bind(source::getX, destination::setX)
			.bind(source::getY, destination::setY))
		.addMap(Line.class, LineDto.class, (conf, source, destination) -> conf
			.mapInner(source::getStart, destination::setStart, PointDto.class)
			.mapInner(source::getEnd, destination::setEnd, PointDto.class))
		.buildMapper();
</pre>

		<p>In line 6 and 7 <code>mapInner</code> operation is used to map <code>Point</code> to <code>PointDto</code> and then assign it to proper
		<code>LineDto</code>'s property. If you do not want to always create new <code>PointDto</code> but map to existing one you will need to
		additionally provide destination's member getter:</p>

<pre class="brush: java; gutter: false;">
	.mapInner(source::getStart, destination::setStart, destination::getStart, PointDto.class)
	.mapInner(source::getEnd, destination::setEnd, destination::getEnd, PointDto.class))
</pre>

		<h3 id="destination-object-construction">Destination object construction</h3>

		<p>As was already mentioned bean-cp can create destination object during mapping:</p>
		
<pre class="brush: java; gutter: false;">
	OrderOverviewDto destination = mapper.map(order, OrderOverviewDto.class);
</pre>

		<p>By default objects are constructed using no-argument constructor. This could be changed using <code>constructDestinationObjectUsing</code>
		declaration. For example suppose that exists <code>OrderOverviewDtoFactory</code> witch should be used to construct <code>OrderOverviewDto</code>
		objects. Here is how to use <code>constructDestinationObjectUsing</code> in that situation (line 5 - 9):</p>
		
<pre class="brush: java">
	Mapper mapper = new MapperBuilder().addMap(
		Order.class,
		OrderOverviewDto.class,
		(conf, source, destination) -> conf
				.constructDestinationObjectUsing(() -> {
					OrderOverviewDto result = OrderOverviewDtoFactory.getOrderOverviewDto();

					return result;
				})
				// and so on...
</pre>

		<p>Be aware that <code>constructDestinationObjectUsing</code> must be first statement before <code>bind</code> and <code>bindConstant</code>
		statements.</p>

		<h3 id="before-after-map">Before and after map actions</h3>

		<p>There are situations when you need to perform an operation before or after mapping. Here is proper code snipped to do that:</p>

<pre class="brush: java">
	Mapper mapper = new MapperBuilder().addMap(
			Order.class,
			OrderOverviewDto.class,
			(conf, source, destination) -> conf
				.beforeMap(() -> Logger.debug(
					"Starting mapping of Order (id: "
					+ source.getId() + ")"))
				
				// Some other stuff here...
				
				.afterMap(() -> Logger.debug(
					"Finished mapping of Order (id: "
					+ source.getId() + ")"))
					
				// and so on...
</pre>
	
		<p>You can also use mapper reference in "before" and "after" actions:</p>
	
<pre class="brush: java">
	Mapper mapper = new MapperBuilder().addMap(
			Order.class,
			OrderOverviewDto.class,
			(conf, source, destination) -> conf
				.beforeMap(mapperRef -> Logger.debug(
					"Starting mapping of Order (id: "
					+ source.getId()
					+ ") by mapper "
					+ mapperRef))
				
				// Some other stuff here...
				
				.afterMap(mapperRef -> Logger.debug(
					"Finished mapping of Order (id: "
					+ source.getId()
					+ ") by mapper "
					+ mapperRef))
					
				// and so on...
</pre>
		<h3 id="field-binding">Field binding</h3>

		<p>In case you need to bind some fields (in example: <code>sourceMember</code> field to <code>destinationMember</code> field):</p>
		
<pre class="brush: java; gutter: false;">
	.bind(() -> { return source.sourceMember; }, v -> { destination.destinationMember = v; })
</pre>

		<h3 id="declarative-map-statement-order">Statement order</h3>
		
		<p>Finally, please note that methods must be executed in the following order:</p>
		
		<ul>
			<li><code>constructDestinationObjectUsing</code> zero or one time</li>
			<li><code>beforeMap</code> zero or many times</li>
			<li><code>useConvention</code> zero or one time (<a href="#user-manual,conventions">conventions are discussed later</a>)</li>
			<li><code>bind</code> and <code>bindConstant</code> and <code>mapInner</code> methods zero or many times in any order</li>
			<li><code>afterMap</code> zero or many times</li>
		</ul>

		<h2 id="converters">Converters</h2>
		
		<h3 id="when-and-how-to-create-converters">When and how to create converter?</h3>

		<p>Time to time you will need to map from or to object which is not JavaBean. There are also situations when object do not have
		default public or protected constructor. For those kind of objects you will need to write <code>converter</code>. Then converters
		can be used to map inner objects just like we did in "<a href="#user-manual,map-inner-objects">Map inner objects" section</a>.
		Good example of valid converter usage is conversion to <a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">LocalDate</a>.
		LocalDate is <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html">value-based</a> class, so it is
		immutable, do not have accessible constructors, but are instead instantiated through factory methods... and it is <strong>not</strong>
		JavaBean.</p>
		
		<p>When you use converter you generally need to write conversion code by your self. For example this code converts
		<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Date.html">Date</a> to
		<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">LocalDate</a>.</p>

<pre class="brush: java; gutter: false;">
	Date input = // ...
	Instant instant = source.toInstant();
	ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());
	LocalDate result = zonedDateTime.toLocalDate();
</pre>

		<p>Here is example how to make and register converter from this code:</p>

<pre class="brush: java; gutter: false;">
	Mapper mapper = new MapperBuilder()
		.addConverter(Date.class, LocalDate.class, source -> {
			Instant instant = source.toInstant();
			ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());
			LocalDate result = zonedDateTime.toLocalDate();

			return result;
		}).buildMapper();
</pre>

		<p>There are few other <code>addConverter</code> methods, but idea is generally similar. For details please have a look at
		<a href="http://localhost:8888/apidocs/release/1.0/com/github/erchu/beancp/MapperBuilder.html">MapperBuilder API specification</a>.</p>

		<h3 id="common-converters">Common converters</h3>

		<p>There are two sets of converters provided with bean-cp: <code>CollectionConverters</code> and <code>NumberConverters</code>. Let the
		code speak for itself.</p>
		
		<p>Conversion from array to collection:</p>
		
<pre class="brush: java;">
	Mapper mapper = new MapperBuilder()
		.addConverter(CollectionConverters.getArrayToCollection(long.class))
		.buildMapper();

	Collection&lt;?&gt; result = mapper.map(new long[] { 1, 2, 3 }, Collection.class);
</pre>
		
		<p>Conversion from collection to array:</p>
		
<pre class="brush: java;">
	Mapper mapper = new MapperBuilder()
		.addConverter(CollectionConverters.getCollectionToArray(String.class))
		.buildMapper();

	Collection&lt;String&gt; collectionInstance = // ...

	String[] result = mapper.map(collectionInstance, String[].class);
</pre>
		
		<p>Number conversion:</p>

<pre class="brush: java;">
	Mapper mapper = new MapperBuilder()
		.addConverter(NumberConverters.get())
		.buildMapper();

	Double result = mapper.map(1l, Double.class);
</pre>

		<h2 id="conventions">Conventions</h2>

		<p><span class="work-in-progress">Coming soon</span></p>

		<h3 id="write-convention">Name-based convention</h3>

		<p><span class="work-in-progress">Coming soon</span></p>

		<h3 id="map-any">Map any convention</h3>

		<p><span class="work-in-progress">Coming soon</span></p>

		<h3 id="write-convention">Write your own convention</h3>

		<p><span class="work-in-progress">Coming soon</span></p>

		<h2 id="big-example">Put it all together</h2>

		<p><span class="work-in-progress">Coming soon</span></p>

		<h2 id="summary">Summary</h2>

		<p><span class="work-in-progress">Coming soon</span></p>
	</section>
	<section class="table-of-contents">
		<div class="table-of-contents">
			<ul>
				<li><a href="#user-manual,setting-up">Setting up environment</a></li>
				<li><a href="#user-manual,first-mapping">First mapping</a></li>
				<li>
					<a href="#user-manual,declarative-maps">Declarative maps in deep</a>
					<ul>
						<li><a href="#user-manual,bind-constant">Bind constant</a></li>
						<li><a href="#user-manual,calculated-members">Calculated members</a></li>
						<li><a href="#user-manual,conditional-mapping">Conditional mapping</a></li>
						<li><a href="#user-manual,null-substitution">Null substitution</a></li>
						<li><a href="#user-manual,map-inner-objects">Map inner objects</a></li>
						<li><a href="#user-manual,destination-object-construction">Destination object construction</a></li>
						<li><a href="#user-manual,before-after-map">Before and after map actions</a></li>
						<li><a href="#user-manual,field-binding">Field binding</a></li>
						<li><a href="#user-manual,declarative-map-statement-order">Statement order</a></li>
					</ul>
				</li>
				<li>
					<a href="#user-manual,converters">Converters</a>
					<ul>
						<li><a href="#user-manual,when-and-how-to-create-converters">When and how to create converter?</a></li>
						<li><a href="#user-manual,common-converters">Common converters</a></li>
					</ul>
				</li>
				<li>
					<a href="#user-manual,conventions">Conventions</a>
					<ul>
						<li><a href="#user-manual,name-based-convention">Name-based convention</a></li>
						<li><a href="#user-manual,map-any">Map any convention</a></li>
						<li><a href="#user-manual,write-convention">Write your own convention</a></li>
					</ul>
				</li>
				<li><a href="#user-manual,big-example">Put it all together</a></li>
				<li><a href="#user-manual,summary">Summary</a></li>
			</ul>
		</div>
	</section>
</div>
